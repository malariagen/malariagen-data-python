import random

import pandas as pd
import pytest
from pandas.api.types import is_integer_dtype

from malariagen_data import ag3 as _ag3
from malariagen_data.anoph.karyotype import AnophelesKaryotypeAnalysis


# Inversions that are generated by Ag3Simulator.init_inversion_tags.
AG3_INVERSIONS = ["2La", "2Rb", "2Rc_col", "2Rc_gam", "2Rd", "2Rj", "2Ru"]


@pytest.fixture
def ag3_sim_api(ag3_sim_fixture):
    return AnophelesKaryotypeAnalysis(
        url=ag3_sim_fixture.url,
        public_url=ag3_sim_fixture.url,
        config_path=_ag3.CONFIG_PATH,
        major_version_number=_ag3.MAJOR_VERSION_NUMBER,
        major_version_path=_ag3.MAJOR_VERSION_PATH,
        pre=True,
        aim_metadata_dtype={
            "aim_species_fraction_arab": "float64",
            "aim_species_fraction_colu": "float64",
            "aim_species_fraction_colu_no2l": "float64",
            "aim_species_gambcolu_arabiensis": object,
            "aim_species_gambiae_coluzzii": object,
            "aim_species": object,
        },
        gff_gene_type="gene",
        gff_gene_name_attribute="Name",
        gff_default_attributes=("ID", "Parent", "Name", "description"),
        default_site_mask="gamb_colu_arab",
        results_cache=ag3_sim_fixture.results_cache_path.as_posix(),
        virtual_contigs=_ag3.VIRTUAL_CONTIGS,
        # Pass the dynamically-generated tag SNP file so that all tag positions
        # are guaranteed to exist in the simulated genotype data.
        inversion_tag_path=ag3_sim_fixture.inversion_tag_path,
    )


@pytest.mark.parametrize("inversion", AG3_INVERSIONS)
def test_load_inversion_tags(inversion, ag3_sim_api):
    api = ag3_sim_api

    # Call the function under test.
    df = api.load_inversion_tags(inversion=inversion)

    # Check return type.
    assert isinstance(df, pd.DataFrame)

    # Check expected columns are present.
    expected_columns = {"inversion", "contig", "position", "alt_allele"}
    assert expected_columns.issubset(set(df.columns))

    # All rows should correspond to the requested inversion.
    assert (df["inversion"] == inversion).all()

    # Check there is at least one tag SNP.
    assert len(df) > 0

    # Positions should be positive integers.
    assert is_integer_dtype(df["position"]) or df["position"].dtype == object
    assert (df["position"] > 0).all()

    # alt_allele should be single nucleotide characters.
    assert df["alt_allele"].str.len().eq(1).all()


def test_load_inversion_tags_not_implemented():
    api = AnophelesKaryotypeAnalysis.__new__(AnophelesKaryotypeAnalysis)
    api._inversion_tag_path = None

    with pytest.raises(NotImplementedError):
        api.load_inversion_tags(inversion="2La")


@pytest.mark.parametrize("inversion", AG3_INVERSIONS)
def test_karyotype(inversion, ag3_sim_api):
    api = ag3_sim_api

    # Parametrize sample_sets with a few representative cases.
    all_sample_sets = api.sample_sets()["sample_set"].to_list()
    all_releases = api.releases
    parametrize_sample_sets = [
        None,
        random.choice(all_sample_sets),
        random.sample(all_sample_sets, min(2, len(all_sample_sets))),
        random.choice(all_releases),
    ]

    for sample_sets in parametrize_sample_sets:
        # Call the function under test.
        df = api.karyotype(
            inversion=inversion,
            sample_sets=sample_sets,
        )

        # Check return type.
        assert isinstance(df, pd.DataFrame)

        # Check expected columns.
        expected_columns = {
            "sample_id",
            "inversion",
            f"karyotype_{inversion}_mean",
            f"karyotype_{inversion}",
            "total_tag_snps",
        }
        assert expected_columns.issubset(set(df.columns))

        # inversion column should always equal the queried inversion.
        assert (df["inversion"] == inversion).all()

        # total_tag_snps should be >= 0 (some may be missing).
        assert (df["total_tag_snps"] >= 0).all()

        # karyotype column should contain values in {0, 1, 2, "<NA>"}.
        valid_karyotype_values = {0, 1, 2, "<NA>"}
        observed_values = set(df[f"karyotype_{inversion}"].astype(str))
        assert observed_values.issubset({str(v) for v in valid_karyotype_values})

        # Number of rows should match the number of samples.
        df_samples = api.sample_metadata(sample_sets=sample_sets)
        assert len(df) == len(df_samples)

        # sample_id values should match.
        assert set(df["sample_id"]) == set(df_samples["sample_id"])


@pytest.mark.parametrize("inversion", AG3_INVERSIONS)
def test_karyotype_with_sample_query(inversion, ag3_sim_api):
    api = ag3_sim_api

    # Call the function under test with a sample_query.
    df = api.karyotype(
        inversion=inversion,
        sample_query="country == 'Angola'",
    )

    # Check return type.
    assert isinstance(df, pd.DataFrame)

    # Check expected columns.
    expected_columns = {
        "sample_id",
        "inversion",
        f"karyotype_{inversion}_mean",
        f"karyotype_{inversion}",
        "total_tag_snps",
    }
    assert expected_columns.issubset(set(df.columns))
